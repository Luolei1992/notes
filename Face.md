## 前端框架相关
### MVVM的理解
```  
M -Model, Model 代表数据模型，也可以在Model 中定义数据修改和操作的业务逻辑；
V -View， View 代表UI 组件，她负责将数据模型转化为UI 展现出来；
VM -ViewModel，ViewModel 监听模型数据的改变和控制视图行为，处理用户交互，简单理解就是一个同步View 和Model 的对象，连接Model 和View
```
### VUE/REACT各自的优缺点
```

```


## 一、 vue相关知识点
### Vue响应式数据原理
```
实现mvvm的双向绑定，是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。

1、实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者
2、实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数
3、实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图
4、mvvm入口函数，整合以上三者
```

### Vue采用异步渲染
```
因为如果不采用异步更新，那么每次更新数据都会对当前组件进行重新渲染，所以为了性能考虑，Vue 会在本轮数据更新后，再去异步更新数据；
```

### Vue的优缺点
```
·轻量级框架
  值关注视图层，是一个构建数据的视图集合，大小只有几十kb；
  Vue.js 通过简介的API 提供高效的数据绑定和灵活的组件系统；
·简单易学
  国人开发，中文文档；
·双向数据绑定
  通过MVVM 思想实现数据的双向绑定，让开发者不用再操作DOM 对象，有更多的时间去思考业务逻辑；
·组件化
  Vue.js 通过组件，把一个单页面应用中的各种模块拆分到一个一个单独的组件（component）中，
  我们只要现在父级应用中写好各种组件标签（占坑），并且在组件标签中写好要传入组件的参数，
  然后再分别写好各种组件的实现（填坑），然后整个应用就算完成了；
·虚拟DOM
  把最终的DOM 操作计算出来并优化，由于这个DOM 操作属于预处理操作，并没有真实的操作DOM，
  所以叫做虚拟DOM ，最后在计算完毕才真正将DOM 操作提交，将DOM 操作变化反映到DOM 树上；
·视图，数据，结构分离
  使数据的更改更为简单，不需要进行逻辑代码的修改，只需操作数据就能完成相关操作；
·运行速度更快
  像比较与react 而言，同样都是擦欧总虚拟DOM，就性能而言， Vue 存在很大的优势；
```

### Proxy 与 Object.defineProperty() 对比
```
Proxy 的优点：
·可以直接监听对象而非属性，并返回一个新对象；
·可以直接监听数值的变化；
·可以劫持整个对象，并返回一个新对象；
Proxy 的缺点：
·Proxy 是es6 提供的新特性，兼容性不好，所以导致Vue3.0 一直没有正式发布让开发者使用

Object.defineProperty() 的优点：
·兼容性好，支持IE9
·IE9 以下的版本不兼容

Object.defineProperty() 的缺点：
·无法监控到数组下标的变化，导致直接通过数组的下标给数组设置值，不能实时响应；
·只能劫持对象的属性，我们需要对每个对象的每个属性进行遍历；
```

### 为什么vue组件中data必须是一个函数？
```
对象为引用类型，当复用组件时，由于数据对象都指向同一个data对象，当在一个组件中修改data时，其他重用的组件中的data会同时被修改；而使用返回对象的函数，
由于每次返回的都是一个新对象（Object的实例），引用地址不同，则不会出现这个问题。
```
### 讲一下Vue的生命周期
### 第一次页面加载会触发哪几个钩子？
```beforeCreate， created， beforeMount， mounted```

### created和mounted的区别
```
created：渲染了data，methods，watch等，但是没渲染html，即通常初始化某些属性值，然后再渲染成视图
mounted：渲染了html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作
```

### vuex是什么？哪种功能场景使用它
```是vue的一个状态管理仓库，在公共数据量大的时候需要用它来管理状态```

### 如何配置 vue 打包生成文件的路径？
```3.0脚手架中在vue.config中module.exports = { assetsDir: 'static' }```

### 什么是不可变数据？ 
```
不可变数据是：不能增删改这个数据
把数据变为不可变数据的方法有四种：
  1.Object.defineProperty方法，将属性的属性描述符writable和configurable都设为false
  2.Object.preventExtensions方法，让一个对象变的不可扩展，也就是永远不能再添加新的属性
  3.Object.seal方法，密封一个对象，这个对象不能添加属性，不能修改或者删除任何现有属性
  4.Object.freeze方法，冻结一个对象
```

### nextTick
```
vue为了保证性能，会把dom修改添加到异步任务，所有同步代码执行完成后再统一修改dom，一次事件循环中的多次数据修改只会触发一次watcher.run()。
也就是通过nextTick，nextTick会优先使用microTask创建异步任务。vue项目中如果需要获取修改后的dom信息，需要通过nextTick在dom更新任务之后创建一个异步任务。
如官网所说，nextTick会在下次 DOM 更新循环结束之后执行延迟回调。
```

### vue 组件间通讯
```
props
$emit
```

### Vue router路由模式，优缺点
```
默认hash模式，URL中带有#号
hash也称为锚点，本身是用来做页面定位的，它可以使对应的id元素显示在可视区域。
hash虽然出现在url中，但不会被包括在http请求中，对后端完全没有影响，因此改变hash不会被重新加载页面。
hash发生变化url都会被浏览器记录下来，从而可以使用浏览器的前进和后退。又称为前端路由，单页面应用的标配。
缺点：
1.本来是拿来做页面定位的，如果拿来做路由的话，原来的锚点功能就不能用了；
2.传参是基于url的，如果传递复杂的数据，会又体积的限制，而history模式不仅可以在url里放参数，还可以将数据放在一个特定的对象中。

history 是基于h5的新api：history.pushState()和history.replaceState()这俩个方法，完成单页面路由切换（改变#哈希后面的路径）
优点：
减少请求/优化网络延迟/提升用户体验/维持页面持久性/前后端彻底分离；

缺点：
1.前进和后退会重新发送请求没有合理利用缓存
2.History缺点因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问 http://xxx/webxiu 就会返回 404，这就是非常不好的。
```

### 单页面应用优缺点
```
1.良好的交互体验
2.良好的前后端工作分离模式
3.减轻服务器压力

1.首屏加载慢
2.不利于SEO
3.不适合开发大型项目
```

### 闭包
```
闭包是指有权访问另外一个函数作用域中的变量的函数.可以理解为(能够读取其他函数内部变量的函数)
闭包的作用: 正常函数执行完毕后,里面声明的变量被垃圾回收处理掉,但是闭包可以让作用域里的 变量,在函数执行完之后依旧保持没有被垃圾回收处理掉
```

### Promise和Async/Await
```
Promise,简单来说就是一个容器，里面保存着某个未来才会结束的时间(通常是一个异步操作的结果)
async用于申明一个function是异步的，而await可以认为是async wait的简写，等待一个异步方法执行完成。
```

### jQuery的实现原理
```
1) jQuery采用的是构造函数模式进行开发的,jQuery是一个类
2) 上面说的常用的方法(CSS、属性、筛选、事件、动画、文档处理)都是定义在jQuery.prototype上的 ->只有jQuery的实例才能使用这些方法
```

### new构造函数时 做了那些事儿
- 创建一个空对象
- this指向这个空对象
- 会执行构造函数里面的代码
- 返回这个对象



### 数组去重
```
 值类型的：
 1.Array.from(new Set(arr)) // 利用set对象的唯一性
 2.利用indexOf !== -1，利用includes()
 引用类型的：
 3.利用对象的key值不能重复：创建一个对象和一个新数组，遍历源数组，如果!arr[i].objName，对象的key值 = 当前值，value = true用于辨识，数组中push当前数据
 4.利用filter + findIndex去重 arr.filter((e, i) => arr.findIndex(item => item.id === e.id) === i);
```


### 什么是事件委托?
```
 如果页面中有多个相同或类似元素都需要绑定同类型事件，此时可以给他们的父级通过addEventListener绑定事件去处理。
 这样做的优点是：
 1.提高性能，只绑定一个函数会节省占用的内存 
 2.动态监听，即使新增的子节点 不用主动绑定事件也可以一样具有和其他元素一样的事件。
```

### 单页面应用 首屏加载慢问题
```
1、去除调试用的map文件
2、路由懒加载
3、vue等文件使用cdn加载（需要配置 externals）
4、压缩文件
```








